{"ast":null,"code":"import { useState, useCallback, useMemo, cloneElement, useRef, createElement, useEffect, forwardRef } from 'react';\nimport clsx from 'clsx';\nimport mergeRefs from 'react-merge-refs';\nimport { nanoid } from 'nanoid/non-secure';\nconst INDETERMINATE_STATE = 'indeterminate';\n\nconst dispatch = value => state => {\n  if (Array.isArray(state)) {\n    const index = state.indexOf(value);\n\n    if (index === -1) {\n      state.push(value);\n    } else {\n      state.splice(index, 1);\n    }\n\n    return [...state];\n  } else if (value !== '') {\n    return [value];\n  }\n\n  return !state;\n};\n\nconst useCheckboxState = function () {\n  let {\n    state: initialState = false,\n    onChange\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const [state, setState] = useState(() => {\n    if (typeof initialState === 'string' && initialState !== INDETERMINATE_STATE) {\n      return [initialState];\n    }\n\n    return initialState;\n  });\n  return {\n    state,\n    setState,\n    onChange: useCallback(e => {\n      const {\n        value\n      } = e.currentTarget;\n      setState(dispatch(value));\n\n      if (typeof onChange === 'function') {\n        onChange(e);\n      }\n    }, [onChange])\n  };\n};\n\nconst lockedStyles = {\n  pointerEvents: 'none'\n};\n/**\n * A simplier way to prevent checking when PCR is in locked mode.\n * This is way simplier than controlling the checkbox using\n * event handlers. Supports IE 11+\n */\n\nconst useLocked = _ref => {\n  let {\n    locked,\n    style\n  } = _ref;\n\n  if (locked) {\n    return { ...lockedStyles,\n      ...style\n    };\n  }\n\n  return style;\n};\n\nconst useIcon = icon => {\n  return useMemo(() => {\n    if (icon) {\n      let type = 'icon';\n\n      if (icon.type === 'img') {\n        type = 'image';\n      } else if (icon.type === 'svg') {\n        type = 'svg';\n      } // icons that contain `type` substring\n      // won't fail with a word boundary search\n\n\n      const re = new RegExp(`\\\\b${type}\\\\b`);\n      return {\n        iconType: icon.props['data-type'] || type,\n        icon: icon.props.className && !re.test(icon.props.className) ? cloneElement(icon, { ...icon.props,\n          className: clsx(icon.props.className, type)\n        }) : icon\n      };\n    }\n\n    return {};\n  }, [icon]);\n};\n\nconst isDefault = (animation, type) => {\n  if (type) {\n    return false;\n  }\n\n  return !animation || animation === 'smooth' || animation === 'pulse';\n};\n/**\n * Responsible for returning an object used by classnames\n * to properly add the className values to the .pretty element.\n */\n\n\nconst useClassNames = (props, isSwitch) => {\n  const {\n    animation,\n    bigger,\n    locked,\n    plain,\n    shape,\n    variant,\n    iconType,\n    hasFocus\n  } = props;\n  return {\n    'p-default': !isSwitch && isDefault(animation, iconType),\n    'p-bigger': bigger,\n    'p-locked': locked,\n    'p-plain': plain,\n    'p-has-focus': hasFocus,\n    [`p-${animation}`]: animation,\n    [`p-${shape}`]: shape,\n    [`p-${variant}`]: variant,\n    [`p-${iconType}`]: iconType\n  };\n};\n\nconst isBoolean = e => typeof e === 'boolean';\n\nconst isNullish = e => e === null || e === undefined;\n\nconst isIndeterminate = e => e === 'indeterminate';\n/**\n * A generic way to setup controlled components by\n * removing  state hook return results, setting `checked`,\n * and `value` props too.\n */\n\n\nconst useControlled = props => {\n  // remove state and state dispatch from the props\n  // eslint-disable-next-line prefer-const\n  let {\n    checked,\n    state,\n    setState,\n    value,\n    defaultValue,\n    ...rest\n  } = props; // if a dispatcher is used, then we're good to run the rest\n  // of the logic\n\n  if (setState) {\n    // if state is defined and checked is NOT defined\n    // then use state to set the value of checked.\n    if ((isBoolean(state) || isIndeterminate(state)) && !isBoolean(checked) && isNullish(checked)) {\n      checked = !!state;\n    } else if (Array.isArray(state)) {\n      // otherwise set checked true if the value is contained\n      // within the state.\n      checked = state.includes(value);\n    } else if (isNullish(checked)) {\n      // The type is not a boolean and is probably a string.\n      // If you're attempting to use this hook in a different\n      // way, then you should considering controlling the component\n      // yourself. Object.is used here just in case ;)\n      checked = Object.is(state, value);\n    } // preset the value prop in controlled mode to an empty\n    // string to prevent 'on' values. Use the defaultValue\n    // if provided\n\n\n    if (isNullish(value)) {\n      value = defaultValue || '';\n    }\n  }\n\n  return {\n    checked,\n    value,\n    state,\n    ...rest\n  };\n};\n\nconst PREFIX = 'pcr_';\n\nconst useUUID = () => useRef(PREFIX + nanoid(8)).current;\n/**\n * Filters out the noise of prop mayhem with PCR. This separates\n * all props from the native HTML props that will eventually get passed\n * to the input element. Generated PCR UUIDs are created here, unless\n * user has specified one of their own.\n */\n\n\nconst useCommonProps = props => {\n  const defaultId = useUUID();\n  const {\n    locked,\n    color,\n    variant,\n    animation,\n    children,\n    style,\n    id = defaultId,\n    className,\n    bigger,\n    hasFocus,\n    ...rest\n  } = props;\n  return {\n    locked,\n    color,\n    variant,\n    animation,\n    children,\n    id,\n    className,\n    bigger,\n    style,\n    hasFocus,\n    htmlProps: rest\n  };\n};\n/**\n * Responsible for extracting common props for radio and checkbox\n * controls.\n */\n\n\nconst useCheckboxRadioProps = props => {\n  const {\n    shape,\n    plain,\n    icon,\n    indeterminate,\n    hasFocus,\n    ...rest\n  } = props;\n  return {\n    shape,\n    plain,\n    icon,\n    indeterminate,\n    ...useCommonProps(rest)\n  };\n};\n/**\n * A tiny component to abstract away pretty-checkbox \"state\" div.\n * Shared by all components.\n */\n\n\nconst State = _ref2 => {\n  let {\n    color,\n    icon,\n    id,\n    children,\n    ...rest\n  } = _ref2;\n  return createElement(\"div\", {\n    className: clsx('state', color && `p-${color}`),\n    ...rest\n  }, icon, createElement(\"label\", {\n    htmlFor: id\n  }, children));\n};\n\nState.displayName = 'State';\n\nconst useIndeterminate = _ref3 => {\n  let {\n    checked,\n    state,\n    indeterminate: indeterminateFromProps\n  } = _ref3;\n  const [indeterminate, setStatus] = useState(false);\n  const ref = useRef(null);\n  useEffect(() => {\n    if (state !== undefined && ref.current) {\n      setStatus(state === 'indeterminate');\n    }\n  }, [state]); // if a prop is passed mark the indeterminate state\n  // we should check to ensure state isn't set to indeterminate\n  // since we don't want ot clobber the state value if\n  // it is defined.\n\n  useEffect(() => {\n    if (state !== 'indeterminate' && ref.current && typeof indeterminateFromProps !== 'undefined') {\n      ref.current.checked = indeterminateFromProps; // fix needs to come from pretty-checkbox\n      // ref.current.indeterminate = indeterminateFromProps;\n\n      setStatus(indeterminateFromProps);\n    }\n  }, [indeterminateFromProps, state]);\n  return {\n    ref,\n    'aria-checked': indeterminate ? 'mixed' : checked\n  };\n};\n\nconst Checkbox = forwardRef((props, ref) => {\n  const {\n    checked,\n    value,\n    state,\n    ...rest\n  } = useControlled(props);\n  const {\n    children,\n    locked,\n    color,\n    id,\n    className,\n    style,\n    indeterminate,\n    icon: propsIcon,\n    htmlProps\n  } = useCheckboxRadioProps(rest);\n  const {\n    ref: intRef,\n    ...aria\n  } = useIndeterminate({\n    state,\n    checked,\n    indeterminate\n  });\n  const styles = useLocked({\n    locked,\n    style\n  });\n  const {\n    icon,\n    iconType\n  } = useIcon(propsIcon);\n  return createElement(\"div\", {\n    style: styles,\n    className: clsx('pretty', useClassNames({ ...props,\n      iconType\n    }), className)\n  }, createElement(\"input\", {\n    ref: mergeRefs([ref, intRef]),\n    value: value,\n    type: \"checkbox\",\n    id: id,\n    checked: checked,\n    ...aria,\n    ...htmlProps\n  }), createElement(State, {\n    id: id,\n    icon: icon,\n    color: color\n  }, children));\n});\nCheckbox.displayName = 'Checkbox';\n\nconst useRadioState = function () {\n  let {\n    state: initialState = false,\n    onChange\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const [state, setState] = useState(initialState);\n  return {\n    state,\n    setState,\n    onChange: useCallback(e => {\n      const {\n        value\n      } = e.currentTarget;\n      setState(current => {\n        if (value !== '') {\n          return value;\n        }\n\n        return !current;\n      });\n\n      if (typeof onChange === 'function') {\n        onChange(e);\n      }\n    }, [onChange])\n  };\n};\n\nconst Radio = forwardRef((props, ref) => {\n  const {\n    checked,\n    value,\n    state,\n    ...rest\n  } = useControlled(props);\n  const {\n    shape = 'round',\n    children,\n    locked,\n    color,\n    id,\n    className,\n    style,\n    icon: propsIcon,\n    htmlProps\n  } = useCheckboxRadioProps(rest);\n  const styles = useLocked({\n    locked,\n    style\n  });\n  const {\n    icon,\n    iconType\n  } = useIcon(propsIcon);\n  return createElement(\"div\", {\n    style: styles,\n    className: clsx('pretty', useClassNames({ ...props,\n      shape,\n      iconType\n    }), className)\n  }, createElement(\"input\", {\n    ref: ref,\n    value: value,\n    type: \"radio\",\n    id: id,\n    checked: checked,\n    ...htmlProps\n  }), createElement(State, {\n    id: id,\n    icon: icon,\n    color: color\n  }, children));\n});\nRadio.displayName = 'Radio';\n\nconst handler = e => {\n  e.currentTarget.setAttribute('aria-checked', e.currentTarget.checked + '');\n};\n/**\n * A small hook to help manage correct aria-checked state when switch\n * is used as an uncontrolled component. We need this to run\n * for a11y purposes. FOr the `switch` role, `aria-checked` is required.\n */\n\n\nconst useAriaChecked = _ref4 => {\n  let {\n    setState,\n    checked\n  } = _ref4;\n  const ref = useRef(null);\n  useEffect(() => {\n    const elem = ref.current;\n    let bound = false;\n\n    if (!setState && !checked && elem) {\n      elem.setAttribute('aria-checked', elem.checked + '');\n      elem.addEventListener('change', handler);\n      bound = true;\n    }\n\n    return () => {\n      if (bound && elem) {\n        elem.removeEventListener('change', handler);\n      }\n    };\n  }, [setState, checked]);\n  return ref;\n};\n\nconst Switch = forwardRef((props, ref) => {\n  const {\n    checked,\n    value,\n    state,\n    ...rest\n  } = useControlled(props);\n  const {\n    children,\n    locked,\n    color,\n    id,\n    className,\n    style,\n    htmlProps\n  } = useCommonProps(rest);\n  const styles = useLocked({\n    locked,\n    style\n  });\n  const htmlRef = useAriaChecked({\n    setState: props.setState,\n    checked\n  });\n  return createElement(\"div\", {\n    style: styles,\n    className: clsx('pretty', 'p-switch', useClassNames(props, true), className)\n  }, createElement(\"input\", {\n    ref: mergeRefs([ref, htmlRef]),\n    type: \"checkbox\",\n    role: \"switch\",\n    value: value,\n    id: id,\n    \"aria-checked\": checked,\n    checked: checked,\n    ...htmlProps\n  }), createElement(State, {\n    id: id,\n    color: color\n  }, children));\n});\nSwitch.displayName = 'Switch';\nexport { Checkbox, Radio, Switch, useCheckboxState, useRadioState };","map":{"version":3,"mappings":"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","names":["INDETERMINATE_STATE","dispatch","value","state","Array","isArray","index","indexOf","push","splice","useCheckboxState","initialState","onChange","setState","React.useState","React.useCallback","e","currentTarget","lockedStyles","pointerEvents","useLocked","locked","style","useIcon","icon","React.useMemo","type","re","RegExp","iconType","props","className","test","React.cloneElement","clsx","isDefault","animation","useClassNames","isSwitch","bigger","plain","shape","variant","hasFocus","isBoolean","isNullish","undefined","isIndeterminate","useControlled","checked","defaultValue","rest","includes","Object","is","PREFIX","useUUID","React.useRef","nanoid","current","useCommonProps","defaultId","color","children","id","htmlProps","useCheckboxRadioProps","indeterminate","State","React.createElement","htmlFor","displayName","useIndeterminate","indeterminateFromProps","setStatus","ref","React.useEffect","Checkbox","React.forwardRef","propsIcon","intRef","aria","styles","mergeRefs","useRadioState","Radio","handler","setAttribute","useAriaChecked","elem","bound","addEventListener","removeEventListener","Switch","htmlRef","role"],"sources":["/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/components/checkbox/useCheckboxState.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/hooks/utility/useLocked.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/hooks/useIcon.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/hooks/utility/useClassNames.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/hooks/utility/useControlled.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/hooks/useUUID.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/hooks/utility/useCommonProps.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/hooks/utility/useCheckboxRadioProps.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/components/state/State.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/components/checkbox/useIndeterminate.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/components/checkbox/Checkbox.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/components/radio/useRadioState.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/components/radio/Radio.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/components/switch/useAriaChecked.js","/Users/tommaso/reactproject/node_modules/pretty-checkbox-react/dist-src/components/switch/Switch.js"],"sourcesContent":["import * as React from 'react';\nconst INDETERMINATE_STATE = 'indeterminate';\nconst dispatch = (value) => (state) => {\n    if (Array.isArray(state)) {\n        const index = state.indexOf(value);\n        if (index === -1) {\n            state.push(value);\n        }\n        else {\n            state.splice(index, 1);\n        }\n        return [...state];\n    }\n    else if (value !== '') {\n        return [value];\n    }\n    return !state;\n};\nexport const useCheckboxState = ({ state: initialState = false, onChange, } = {}) => {\n    const [state, setState] = React.useState(() => {\n        if (typeof initialState === 'string' && initialState !== INDETERMINATE_STATE) {\n            return [initialState];\n        }\n        return initialState;\n    });\n    return {\n        state,\n        setState,\n        onChange: React.useCallback((e) => {\n            const { value } = e.currentTarget;\n            setState(dispatch(value));\n            if (typeof onChange === 'function') {\n                onChange(e);\n            }\n        }, [onChange]),\n    };\n};\n","const lockedStyles = { pointerEvents: 'none' };\n/**\n * A simplier way to prevent checking when PCR is in locked mode.\n * This is way simplier than controlling the checkbox using\n * event handlers. Supports IE 11+\n */\nexport const useLocked = ({ locked, style }) => {\n    if (locked) {\n        return {\n            ...lockedStyles,\n            ...style,\n        };\n    }\n    return style;\n};\n","import * as React from 'react';\nimport clsx from 'clsx';\nexport const useIcon = (icon) => {\n    return React.useMemo(() => {\n        if (icon) {\n            let type = 'icon';\n            if (icon.type === 'img') {\n                type = 'image';\n            }\n            else if (icon.type === 'svg') {\n                type = 'svg';\n            }\n            // icons that contain `type` substring\n            // won't fail with a word boundary search\n            const re = new RegExp(`\\\\b${type}\\\\b`);\n            return {\n                iconType: icon.props['data-type'] || type,\n                icon: icon.props.className && !re.test(icon.props.className)\n                    ? React.cloneElement(icon, {\n                        ...icon.props,\n                        className: clsx(icon.props.className, type),\n                    })\n                    : icon,\n            };\n        }\n        return {};\n    }, [icon]);\n};\n","const isDefault = (animation, type) => {\n    if (type) {\n        return false;\n    }\n    return !animation || animation === 'smooth' || animation === 'pulse';\n};\n/**\n * Responsible for returning an object used by classnames\n * to properly add the className values to the .pretty element.\n */\nexport const useClassNames = (props, isSwitch) => {\n    const { animation, bigger, locked, plain, shape, variant, iconType, hasFocus } = props;\n    return {\n        'p-default': !isSwitch && isDefault(animation, iconType),\n        'p-bigger': bigger,\n        'p-locked': locked,\n        'p-plain': plain,\n        'p-has-focus': hasFocus,\n        [`p-${animation}`]: animation,\n        [`p-${shape}`]: shape,\n        [`p-${variant}`]: variant,\n        [`p-${iconType}`]: iconType,\n    };\n};\n","const isBoolean = (e) => typeof e === 'boolean';\nconst isNullish = (e) => e === null || e === undefined;\nconst isIndeterminate = (e) => e === 'indeterminate';\n/**\n * A generic way to setup controlled components by\n * removing  state hook return results, setting `checked`,\n * and `value` props too.\n */\nexport const useControlled = (props) => {\n    // remove state and state dispatch from the props\n    // eslint-disable-next-line prefer-const\n    let { checked, state, setState, value, defaultValue, ...rest } = props;\n    // if a dispatcher is used, then we're good to run the rest\n    // of the logic\n    if (setState) {\n        // if state is defined and checked is NOT defined\n        // then use state to set the value of checked.\n        if ((isBoolean(state) || isIndeterminate(state)) &&\n            !isBoolean(checked) &&\n            isNullish(checked)) {\n            checked = !!state;\n        }\n        else if (Array.isArray(state)) {\n            // otherwise set checked true if the value is contained\n            // within the state.\n            checked = state.includes(value);\n        }\n        else if (isNullish(checked)) {\n            // The type is not a boolean and is probably a string.\n            // If you're attempting to use this hook in a different\n            // way, then you should considering controlling the component\n            // yourself. Object.is used here just in case ;)\n            checked = Object.is(state, value);\n        }\n        // preset the value prop in controlled mode to an empty\n        // string to prevent 'on' values. Use the defaultValue\n        // if provided\n        if (isNullish(value)) {\n            value = defaultValue || '';\n        }\n    }\n    return { checked, value, state, ...rest };\n};\n","import * as React from 'react';\nimport { nanoid } from 'nanoid/non-secure';\nconst PREFIX = 'pcr_';\nexport const useUUID = () => React.useRef(PREFIX + nanoid(8)).current;\n","import { useUUID } from '../useUUID';\n/**\n * Filters out the noise of prop mayhem with PCR. This separates\n * all props from the native HTML props that will eventually get passed\n * to the input element. Generated PCR UUIDs are created here, unless\n * user has specified one of their own.\n */\nexport const useCommonProps = (props) => {\n    const defaultId = useUUID();\n    const { locked, color, variant, animation, children, style, id = defaultId, className, bigger, hasFocus, ...rest } = props;\n    return {\n        locked,\n        color,\n        variant,\n        animation,\n        children,\n        id,\n        className,\n        bigger,\n        style,\n        hasFocus,\n        htmlProps: rest,\n    };\n};\n","import { useCommonProps } from './useCommonProps';\n/**\n * Responsible for extracting common props for radio and checkbox\n * controls.\n */\nexport const useCheckboxRadioProps = (props) => {\n    const { shape, plain, icon, indeterminate, hasFocus, ...rest } = props;\n    return { shape, plain, icon, indeterminate, ...useCommonProps(rest) };\n};\n","import * as React from 'react';\nimport clsx from 'clsx';\n/**\n * A tiny component to abstract away pretty-checkbox \"state\" div.\n * Shared by all components.\n */\nexport const State = ({ color, icon, id, children, ...rest }) => {\n    return (React.createElement(\"div\", { className: clsx('state', color && `p-${color}`), ...rest },\n        icon,\n        React.createElement(\"label\", { htmlFor: id }, children)));\n};\nState.displayName = 'State';\n","import * as React from 'react';\nexport const useIndeterminate = ({ checked, state, indeterminate: indeterminateFromProps, }) => {\n    const [indeterminate, setStatus] = React.useState(false);\n    const ref = React.useRef(null);\n    React.useEffect(() => {\n        if (state !== undefined && ref.current) {\n            setStatus(state === 'indeterminate');\n        }\n    }, [state]);\n    // if a prop is passed mark the indeterminate state\n    // we should check to ensure state isn't set to indeterminate\n    // since we don't want ot clobber the state value if\n    // it is defined.\n    React.useEffect(() => {\n        if (state !== 'indeterminate' &&\n            ref.current &&\n            typeof indeterminateFromProps !== 'undefined') {\n            ref.current.checked = indeterminateFromProps;\n            // fix needs to come from pretty-checkbox\n            // ref.current.indeterminate = indeterminateFromProps;\n            setStatus(indeterminateFromProps);\n        }\n    }, [indeterminateFromProps, state]);\n    return {\n        ref,\n        'aria-checked': indeterminate ? 'mixed' : checked,\n    };\n};\n","import * as React from 'react';\nimport clsx from 'clsx';\nimport mergeRefs from 'react-merge-refs';\nimport { useCheckboxState } from './useCheckboxState';\nimport { useLocked } from '../../hooks/utility/useLocked';\nimport { useIcon } from '../../hooks/useIcon';\nimport { useClassNames } from '../../hooks/utility/useClassNames';\nimport { useControlled } from '../../hooks/utility/useControlled';\nimport { useCheckboxRadioProps } from '../../hooks/utility/useCheckboxRadioProps';\nimport { State } from '../state/State';\nimport { useIndeterminate } from './useIndeterminate';\nexport const Checkbox = React.forwardRef((props, ref) => {\n    const { checked, value, state, ...rest } = useControlled(props);\n    const { children, locked, color, id, className, style, indeterminate, icon: propsIcon, htmlProps, } = useCheckboxRadioProps(rest);\n    const { ref: intRef, ...aria } = useIndeterminate({ state, checked, indeterminate });\n    const styles = useLocked({ locked, style });\n    const { icon, iconType } = useIcon(propsIcon);\n    return (React.createElement(\"div\", { style: styles, className: clsx('pretty', useClassNames({\n            ...props,\n            iconType,\n        }), className) },\n        React.createElement(\"input\", { ref: mergeRefs([ref, intRef]), value: value, type: \"checkbox\", id: id, checked: checked, ...aria, ...htmlProps }),\n        React.createElement(State, { id: id, icon: icon, color: color }, children)));\n});\nCheckbox.displayName = 'Checkbox';\nexport { useCheckboxState };\n","import * as React from 'react';\nexport const useRadioState = ({ state: initialState = false, onChange } = {}) => {\n    const [state, setState] = React.useState(initialState);\n    return {\n        state,\n        setState,\n        onChange: React.useCallback((e) => {\n            const { value } = e.currentTarget;\n            setState(current => {\n                if (value !== '') {\n                    return value;\n                }\n                return !current;\n            });\n            if (typeof onChange === 'function') {\n                onChange(e);\n            }\n        }, [onChange]),\n    };\n};\n","import * as React from 'react';\nimport clsx from 'clsx';\nimport { State } from '../state/State';\nimport { useLocked } from '../../hooks/utility/useLocked';\nimport { useIcon } from '../../hooks/useIcon';\nimport { useClassNames } from '../../hooks/utility/useClassNames';\nimport { useControlled } from '../../hooks/utility/useControlled';\nimport { useCheckboxRadioProps } from '../../hooks/utility/useCheckboxRadioProps';\nimport { useRadioState } from './useRadioState';\nexport const Radio = React.forwardRef((props, ref) => {\n    const { checked, value, state, ...rest } = useControlled(props);\n    const { shape = 'round', children, locked, color, id, className, style, icon: propsIcon, htmlProps, } = useCheckboxRadioProps(rest);\n    const styles = useLocked({ locked, style });\n    const { icon, iconType } = useIcon(propsIcon);\n    return (React.createElement(\"div\", { style: styles, className: clsx('pretty', useClassNames({\n            ...props,\n            shape,\n            iconType,\n        }), className) },\n        React.createElement(\"input\", { ref: ref, value: value, type: \"radio\", id: id, checked: checked, ...htmlProps }),\n        React.createElement(State, { id: id, icon: icon, color: color }, children)));\n});\nRadio.displayName = 'Radio';\nexport { useRadioState };\n","import * as React from 'react';\nconst handler = (e) => {\n    e.currentTarget.setAttribute('aria-checked', e.currentTarget.checked + '');\n};\n/**\n * A small hook to help manage correct aria-checked state when switch\n * is used as an uncontrolled component. We need this to run\n * for a11y purposes. FOr the `switch` role, `aria-checked` is required.\n */\nexport const useAriaChecked = ({ setState, checked }) => {\n    const ref = React.useRef(null);\n    React.useEffect(() => {\n        const elem = ref.current;\n        let bound = false;\n        if (!setState && !checked && elem) {\n            elem.setAttribute('aria-checked', elem.checked + '');\n            elem.addEventListener('change', handler);\n            bound = true;\n        }\n        return () => {\n            if (bound && elem) {\n                elem.removeEventListener('change', handler);\n            }\n        };\n    }, [setState, checked]);\n    return ref;\n};\n","import * as React from 'react';\nimport clsx from 'clsx';\nimport { useClassNames } from '../../hooks/utility/useClassNames';\nimport { useControlled } from '../../hooks/utility/useControlled';\nimport { useLocked } from '../../hooks/utility/useLocked';\nimport { State } from '../state/State';\nimport { useCommonProps } from '../../hooks/utility/useCommonProps';\nimport mergeRefs from 'react-merge-refs';\nimport { useAriaChecked } from './useAriaChecked';\nexport const Switch = React.forwardRef((props, ref) => {\n    const { checked, value, state, ...rest } = useControlled(props);\n    const { children, locked, color, id, className, style, htmlProps } = useCommonProps(rest);\n    const styles = useLocked({ locked, style });\n    const htmlRef = useAriaChecked({ setState: props.setState, checked });\n    return (React.createElement(\"div\", { style: styles, className: clsx('pretty', 'p-switch', useClassNames(props, true), className) },\n        React.createElement(\"input\", { ref: mergeRefs([ref, htmlRef]), type: \"checkbox\", role: \"switch\", value: value, id: id, \"aria-checked\": checked, checked: checked, ...htmlProps }),\n        React.createElement(State, { id: id, color: color }, children)));\n});\nSwitch.displayName = 'Switch';\n"]},"metadata":{},"sourceType":"module"}